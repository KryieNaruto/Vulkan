### 2024年1月17日04:56:41
- 重建交换链
  - docking
  - 字体
---
### 2024年1月20日00:50:45
  - 新建文件的窗体
---
### 2024年1月22日01:37:33
  - 文件列表
---
### 2024年1月23日01:34:12
  - 创建项目，明天开始整序列化，似乎有点难度
---
### 2024年1月24日02:08:02
  - 打开项目，粗略尝试了一下json的序列化与反序列化，了解了一下protocol buf,这将作为我的第二选择，因为需要时间去学习
---
### 2024年1月27日22:37:09
  - 文件的新建保存，数据的序列化，这里防止我忘记，记录一下。
    - 每个需要有序列化和反序列化的功能的类，需要完成serializeToJson,deserializeToObj两个函数，分别是obj序列化为json，json反序列化为obj。
    - 然后使用ThirdPartyManager::jsoncpp_manager中的addValue()来保存序列化内容，使用getObjectFromFile<T>来反序列化。
    - 其中是通过json文件路径作为索引。map<std::string,Json::Value> m_values; Value是根节点。
  - 完成了非常基础的序列化和反序列化，用的json作为数据传递格式。明天开始Scene面板的编写
--- 
### 2024年01月30日 00:32:57
  - 开始写Resource层了，ZResource继承自ZClass，继承自ZResource的类统一R开头。
  - ZResource的路径是基于g_proj_info->m_root_path下的resources文件夹。
  - 还没想好Shader和Pipeline该如何放在一起。
  - 24->27号那4天工作日把星蝶公主4部看完了。双休日不写代码
---
### 2024年1月31日00:58:07
  - 无限火力开了，把Queue和CommandBuffer进行了简单的封装。
---
### 2024年2月1日00:35:04
  - 把RenderPass Begin分装了一下，修复了GPU高占用的问题，原来 presentMode 是立即模式，现在改成FIFO了，随之而来的是各种小BUG，全部修复完成后仍旧有30%的GPU占用，不过CPU从20%降到了6%。
--- 
### 2024年2月5日22:25:30
  - 编译了一下Shaderc和spirv-reflect，明天学习一下怎么用
---
### 2024年02月07日 22:41:13
  - 麻了，整了好几天的shaderc，结果hlsl编译不了，妥协了，换glsl了，有时间把dxc整合进来以实现编译hlsl
---
### 2024年2月10日22:18:35
  - shader 反射已完成input location, descriptorSetLayout和pipelineLayout的自动创建。
  - 只需要再新建一个Material类，把Shader和DescriptorSet、Buffer、Texture结合起来，就可以开始最基本的工作了
#### 2024年2月11日03:05:11
  - emmm, 又写了一个RCamera来分离出Scene Editor的渲染画面，目前花屏，不过这是好的错误，起码能看见什么东西，而不是一片漆黑（虽说正常是一片漆黑）。代码写的太上头，都忘记时间了，直接睡大觉...
---
### 2024年2月12日22:34:12
  - 对RenderPass进行了再度封装，把Attachment Subpass也整合进了RRenderPass中。
  - RRenderPass : public ZResource
  - Subpass     : public vkObject
  - 这里记录一下对renderpass、subpass的新理解
    - VkRenderPass : AttachmentDescription,这个是对Framebuffer中的ImageView的资源描述，其中finalLayout 是RenderPass结束后，image的最终布局。
    - VkSubpassDescription: AttachmentReference, 这个是subpass中，对renderpass指定的Attachment的引用，index是UNUSED，layout则是subpass所需要的布局
    - VkSubpassDependency: subpass之间的依赖，可以等价于renderpass内部的pipelineBarrier.
  - 关于Dynamic Render ，看起来确实挺方便的。只需要指定完RenderBeginInfo就可以了，不用再预先创建RenderPass和Framebuffer,  无非就是在渲染结束的时候手动对image layout进行转换，真挺方便的，等我实在是不向整renderpass繁琐的步骤的时候，就引入这个  
---
### 2024年2月14日22:53:37
  - 昨天去叶家玩了，今天回来写了一点，NSight调试无法改变scene窗口，会崩溃。RenderDoc 在分配swapchain image memory的时候会有memory type 不适配的错误，就算强行返回0，直接崩溃。
---
### 2024年2月15日22:22:26
  - 问题找到了，在bindImageMemory的时候，如果图像太小，memReq.alignment是0x10=256,图像稍微大一点就是0x4000 = 0x10 * 64; 报错的信息是memoryOffset 必须是alignment的整数倍，所以只需要再获得alignment的时候，对m_image_offset_current 求最小公倍数就行了。
  - 目前的问题就是fragment shader output 没有attachment来接受，我不知道怎么回事。等我把model相关内容写完了再进行调试把...
  - 就在刚才，用RenderDoc调试了一下，原来是我的subpass description没有把color attachment ref的数据填入。现在已经好了，就是第一次执行会有提示验证层错误
### 2024年2月20日23:20:30
  - 完成了RVertex,RMesh，RModel,RShader,Shader,RMaterial的大致框架
  - 完成了Buffer及其衍生的Vertex/Uniform/Index Buffer。根据typeBit来索引Buffer,通过Offset,Size来跟踪BufferMemory。
---
### 2024年02月27日 03:46:33
  - 完成了UniformBuffer 与DescriptorSet的配对,RenderDoc调试已经正确接收到了ubo全0的数据。接下来是cpp数据与ubo 的配对，打算新加一层，连接数据与UniformBuffer的配对
  - Texture的支持还没写
---
### 2024年02月29日 11:38:35
  - 完成了UniformBuffer与DescriptorSet的简易配对，这里记录一下。
  - Core::Core_Pool::g_draw_func 通过RMaterial 保存func, 这个func为lambda表达式，在RMaterial::bind() 前，会执行这个func(); func里是ubo与descriptorSet的绑定， 例：
    ```c++
      RMaterial* p_mat = new RMaterial("Name");
      p_mat->setShader(getShader());
      addDrawFuncIntoPool(p_mat,[]() -> void{
        const auto& _mat = RMaterial::getRMaterial("Name")
        const auto& _cam = RCamera::getMainCamera(); 
        // setIndex | binding| data| offset
        _mat->bindData(0,0,_cam->getProperty(),0);
      });
---
### 2024年3月5日22:17:04
  - 记录一下对bindless的学习
    ```c++
    // 需要VK_KHR_push_descriptor和VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME扩展。
    // VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT: descriptorSet无需全部提供
    // VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT： 可以再命令记录阶段更新set
    vkdescriptorSetLayout.flags = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT | VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT;
  - vkdescriptorSetLayoutCreateInfo中pNext 指定为VkDescriptorBindingFlagsEXT[binding_count]
  - VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT修饰的VkDescriptorBindingFlagsEXT 必须是binding的最大值，例如一个set有5个binding，则必须是binding4 是该标志位。有了这个标志位，bindingCount会自动置为最大值
  - descriptorSetAllocateInfo 需要指定pNext为VkDescriptorSetVariableDescriptorCountAllocateInfo，否则会提示没有用到的空槽未被update
  - 修改了Shader的setup函数，现在可以正确识别不同stage的相同binding
---
### 2024年3月20日21:58:18
  - 渲染预先分配的显存有点不够用，需要将空闲区域进行整合，需要重构几乎半个项目...
  - Shader类更加健壮了，目前Blinn-Phong 在RenderDoc中数据全部正确，但是没有渲染出来。
  - RLight 目前只是一个抽象，没有model作为绘制内容
  - RShape ：一些简单几何体的基类，目前实现了RPlane.
  - RMaterial 目前亟需实例为Material，以可视化Material
  - 新增了最重要的Shader和数据绑定的函数:
    ```c++
      auto _func = [](void* _mat,void* _mesh,void* _lights); 
      addFuncIntoDrawFunc_3(void* _shader ,void* _func);
  - Mesh网格的最终完善，坐标轴无法通过目前我的算法绘制出X,Z轴[无法解决的精度问题，或者我还没有找到合适的算法]
  - 还有许多未来得及记录东东
---
### 2024年3月21日14:23:43
  - 重大修改：
    ``` c++
      // _func 为 [](void* _mat,void* _mesh,void* _lights,void* _parent);
      // _parent 。如果model A是其他类 B的成员，也就是说类B 需要有一个绘制模型的功能，故加入A作为成员，而渲染时需要B 的参数
      // _parent 可为Null ,当其为Null时， 则执行(void*,void*,void*)调用，否则则为4个参数
      addFuncIntoDrawFunc_3(void* _shader ,void* _func);
#### 2024年03月21日 22:47:59
  - 目前整个渲染管线已经正确渲染Blinn-phong的光照模型，但是没有支持uniform buffer的bindless，故需要重构反射生成DescriptorSet的代码。
  - 新增Slot, SlotData类，分别对应 Set与Binding，将反射生成vkdescriptorSet相关对象交由这2个类完成，RMaterial将由Slot组成
    ``` c++
      // Slot 由spv reflect set信息解析
      // 其中Slot会将其解析为逐个Binidng的详细信息,然后交由SlotData继续解析
      Slot(SpvReflectDescriptorSet* _reflect_info);
      // spv reflect binding, 由spv reflect set取出，其中包含了binidng的所有详细信息
      // 其中将通过m_struct_property 保存uniform 的结构体信息
      SlotData(SpvReflectDescriptorBinding* _binding_info);
      // 结构体属性
      // [Struct Name] [Member Name] [size,offset]
      std::unordered_map<std::string,
      std::unordered_map<std::string, std::pair<size_t,size_t>>> m_struct_property;
  - 数据绑定也需要交由Slot接管，将重新进行数据绑定的设计
---
### 2024年03月22日 21:40:38
  - 完成了Slot SlotData的基础架构，已经完全支持UBO了，Texture待解决.
  - Slot 可以通过 Set Id ,Binding Id/ Binding Name, Member Index/Member Name 来完成精准的数据绑定
---
### 2024年03月23日 19:44:14
  - 完成了Slot 的编写。但是有一个之前没有的问题，就是如果Tex,Light count为0时，之前不会提示#bindnig 0 index 0 使用中，未update。 所以为Slot 添加了VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT，该标志位作用是如果shader中声明了10个变量，而你之传入3个，则剩余7个不会被视作资源引入，就不会提示上述警告。
  - 内存碎片回收问题需要加紧想办法了。
### 2024年03月23日 22:29:17
  - 目前Descriptor Bindless完全正确，非常智能。根据SlotData中数据数量来设置Variable Count，创建DescriptorSet,也就是说创建出来的Set完美匹配Shader，无任何警告错误！
  - 光源理论无上限，但是我在imgui上设置了8个上限。所有光源效果叠加完全正确！
---
### 2024年3月25日19:28:43
  - 解决了一大堆由于重构DescriptorSet带来的问题。意外发现了模型导入时，多Mesh的情况下，index错误的问题。目前完全正确，已经过19w顶点数，103Mesh数，24Texture数的大型复杂模型测试。
---
### 2024年3月27日00:24:13
  - 对场景进行抽象，将Camera，Light,Model等之前在Core_Pool中管理的对象交由Scene保存，以Scene为单位进行绘制。
  - File Editor开发。
---
### 2024年3月28日21:20:32
  - 今天对Model进行了简单的效率优化。
    - 以RMaterial 为索引，分类所有的Mesh，drawcall以RMaterial为单位
    - RMaterial 下有多个Mesh,将这些Mesh全部合并，最终得到RMaterial数量的Mesh
    - 最终的DrawCall次数为RMaterial数量而非Mesh数量。
    - 在100+Mesh, 120w+ 顶点数的复杂模型，Blinn-phong 光照模型的测试下，帧数从8FPS 提升至30FPS
  - 继续多线程加载模型了。
  - 修改了大量细节代码
  - 添加拖动文件
  - 对DrawCall进行合并优化，在白模的状态下，绘制合并模型。帧率达到垂直同步；
  - 新的优化思路
    - 有大量Material重复，合并重复Material
    - 根据合并后的Material,再次合并RMesh
---
### 2024年3月29日13:04:52
  - 昨天晚上熄灯了，今天完成了最后的优化， FPS 从8 FPS 提甚至 50 FPS 。
  - 需要开始构思多线程加载模型。
### 2024年3月29日18:03:00
  - 多线程加载模型，只是简单的把processNode 全部并行，30MB 模型加载时间从70s 缩短至 8s.
  - 先去吃个饭，之后细细构思如何并行纹理、顶点、索引
---
### 2024年3月31日22:59:20
  - 修了一堆的小Bug。
  - 增加了Shader Slot的文字版显示
  - 增加了初步的天空盒，但是Cube顶点生成错误
  - 编译需要太长时间了，导致现在效率缓慢。
### 2024年4月1日22:53:38
  - 完成了立方体，Image_Cube类型的天空盒。对HDRI全景图的天空盒支持需要球体。但是RenderDoc调试后似乎有一点问题。
  - 增加了Material Texture插槽的可视化。问题就是ImageCube 被View访问后，仍旧只显示Layer0的Image。
  - 打算将TextureEXT加载纹理数组时，直接加载所有纹理到TextureEXT,然后再COPY到一个TextureEXT并保存进成员，这样方便Material 面板中，Texture Cube/Array类型的可视化。现在是只有Layer0 是正确的，其余是黑色。
---
### 2024年4月2日22:59:33
  - HDRI天空盒正确，但是球体坐标有问题。
    - 球体顶点、索引正确。法线 UV错误
  - Material 天空盒的可视化，6面展开形式，昨天的问题是由于imgui image也会有mipmap，而我除了layer0的mipmap生成了，其余的只有mipmap0, 其他等级为黑。
  - 由于修改了SlotData的TextureEXT加载机制，模型现在如果没有纹理也会应用“default"纹理，为全黑。
  - 纹理加载不是多线程。编译太耗时间，导致效率太低。
--- 
### 2024年4月3日15:33:51
  - 天空盒已经完美解决了，HDRI支持拖动图片。Cube暂时还不支持，Cube是一个Image 有多层，而我的逻辑是多个Image 有一层。需要额外的代码进行绑定.
### 2024年4月3日23:03:14
  - 艹了他马的，这破学校又他妈熄灯了，艹，又写到一半死机了，艹nm的，傻diao
  - 在调icon的显示布局，这次优化了图标大小，第一次运行会自适应一次大小。之后使用滑轮可以控制大小，这学校是真傻b啊。
---
### 2024年4月4日17:37:50
  - 布局搞好了，Material布局有点小问题，懒得弄了。
  - 增加了一些图标。
  - 给Material 增加了添加纹理功能，现在能添加一个新纹理。
  - 明天吧增加光源和基础模型的功能加上。再开始整法线贴图
---
### 2024年4月5日15:52:32
  - 才发现当初Camera有问题。这里记录一下。
    - glm perspective [1][1] 需要翻转
    - m_rotate 代表绕XYZ轴旋转，[俯仰][偏航][翻滚], 所以鼠标X增加代表偏航增加...
---
### 2024年4月6日22:27:42
  - 烦人，修了整整一天的BUG。
  - 增加了Shape和Light的添加，Material可以应用;
  - 增加了对光源和天空盒的控制。无光源时，摄像机为光源。
  - 多光源叠加有问题，不知道为什么。本应该是亮部的地方，会有另一个光源的暗部.
  - 增加了光源的衰减与聚光灯范围。但是聚光灯有问题。没时间了...留明天了
--- 
### 2024年4月7日13:37:51
  - OK，基础模型，模型，光源，材质的添加目前全部正确。Texture Array目前尚未支持。
  - 开始整Texture Array以适应法线贴图
### 2024年4月7日21:14:39
  - 先整阴影， 添加了一个用于渲染深度的RenderPass【RENDER_PASS_2】， 有2个subpass,第一个subpass渲染深度，第二个subpass将深度从R32->RGBA8，其中的subpass使用如下
    - shader 使用 input_attachment_index 指定RenderPass中的AttachmentReference Index,然后类型为subpassInput.使用subpassLoad加载
    - ``` glsl
      layout(input_attachment_index = 0, set = 0,binding = 0) uniform subpassInput _inputDepth;
      void main() {
           float _depth = subpassLoad(_inputDepth).r;
      } 
    - 设置subpass [0],[1]的dependency和[1]input attachment
    - descriptor type 设置为input_attachment
    - image layout 必须要有input_attachment | xxx_attachment_optimal
    - cpp端使用vkNextSubpass
  - 如果subpass理解了，我对vk的认知将更加深入！！！！！！！！之后的G-Buffer是轻轻松松
  - ---
  - GG ,Pipeline Stage需要包含Renderpass需要用到的所有Shader Module,也就是说，如果是多subpass, shader stage 是4个起步。
  - Pipeline createInfo 中有subpass，解决了
  - 目前一切正常，subpass 0 depth渲染完成后，input给subpass 1,渲染出可视的depth信息用于调试。
  - 但是SceneObject 的信息目前还有点问题，光源移动，depth给出的信息并没有随之移动。且imgui image 输出color image 会一直闪烁，可能是深度精度问题。也可能是shader问题
  - 平面坐标有问题
---
### 2024年4月8日22:33:59
  - 完成了深度图的渲染，可以将摄像增加到任意位置进行渲染深度图操作。会遇到多Camera渲染一组模型，导致模型Material被重复使用，这里只能用内存换速度，将Camera设为组，复制一份Material组。在渲染时，根据Camera & Shader 切换Material组。
  - 坐标系统现在必须得重构，前期坐标系统没有设计好，导致现在极其难调试
  - 平行光不能使用透视投影渲染深度，需要使用正交投影。等坐标系统修改完成再进行修改。
### 2024年4月9日00:14:14
  - 数据结构进行了初步的搭建。明天需要大改来修正。
---
### 2024年4月10日11:48:55
  - 完成了坐标系的统一，现在所有物体都是基于RObjectProperty属性。旋转计算采用四元数。
  - 亟需将屏幕空间鼠标-> 世界空间。
  - 深度渲染已经正确，但是无法找到合适的算法对深度进行归一。目前是单纯的取反归一，当物体临近远平面，深度几乎无法看出变化。
### 2024年04月10日 20:50:02
  - 受不了了- -，正交投影得到的深度是负数。不知道为什么......导致物体深度一直是0, 一直处于阴影中
  - 今天一天啥也没干，一直在调BUG。这个深度图就是渲染不对。
### 2024年4月11日19:30:52
  - 终于是搞好了，正交投影的zNear和zFar如果差距过大，就会导致物体深度是负数。没有时间去细算为什么。
  - 这个阴影映射非常奇怪，需要zNear和zFar在一个非常好的区间内，Point Spot阴影才会生效，且区间很小。Paraell和点光源区间又不一致；
  - 暂且算是增加了光源阴影渲染，PCF阴影柔滑。
  - 开始点光源6面阴影的处理了。
### 2024年4月11日22:54:05
  - 清楚了为什么正交可用区间这么小了。
  - 正交后的深度是线性的，其中斜率=  -2/(f-n), 这导致fn越大，斜率越大，区间也就越小。
  - 打算新添加一个用于debug绘制点线面的集合着色器，来方便我调试。
  - 模型材质合批后，部分复杂模型的材质合批有问题。
  - 风格化村庄的模型，image不够用的处理方式。
--- 
### 2024年4月12日20:07:22
  -  今天一天都在搞release的发布。跨dll使用STL 容器坑巨多，而我都是STL容器。
  -  release发布完成了，到头来还是把各种 -d.dll的加上了，还不如debug模式发布，带上这些dll
  -  其中 Core::ZFileManager中的GetFileAttributes ，在Release下需要wstring().c_str(), 而Debug下要用string().c_str();
---
### 2024年4月15日14:33:25
  - 前两天中期答辩，玩了两天。
  - 加入dynamic  renderpass 以方便材质编辑器的开发
  - 麻了，我这个显卡的最终支持是2021年，dynamic renderpass的扩展时2022年
---
### 2024年4月16日22:45:31
  - Material Editor的界面编写，有点举步维艰。只完成了背景和最最最基础的Node节点测试
---
### 2024年04月17日 22:13:32
  - Material Editor的编写难度有些超出我的预料了，现在还在写最最最基础的页面
---
### 2024年04月18日 21:28:40
  - 完成了Material最最最基础的beginNode ，其中beginTemplate区间可以增加一个任意的ImGui控件
  - 缩略图
  - 选中高亮，框选
  - 连线明天再整把
### 2024年04月18日 22:58:31
  - 学习一下CMAKE ，把VS项目转化成CMAKE ，之后使用CLion开发
---
### 2024年04月19日 16:32:36
  - 完成了VS项目到CMake的转换，并通过CLion修复了一直以来的概率启动失败的问题，仍旧是未初始化的问题
---
### 2024年4月22日22:42:59
  - 靠，项目想整跨平台到Linux,搞了两天终于把所有的环境全部搞好了，编译器的各种错误也解决了，却忘记了Lib是Windows的，Linux是so，需要把所有的库全部重新编译，实在是搞不起了，只有等毕业了再慢慢转吧。
  - 明天开写，浪费了10天
---
### 2024年4月23日16:52:30
  - 完成了Connection的处理。有点过于复杂了。
  - 完成了Link的处理，目前有点小BUG， Input可以有多个输入，而Output只能有一个输出。这与理想相反。
---
### 2024年4月24日22:24:33
  - 完成了Material Editor连连看模式的样式编写。
  - 需要开始进行Material Editor 如何与Resource进行联动。
  - 目前是
    - ZResource 包含 Template* p_template进行对Node节点的数据管理，Template 中包含SlotTemplate，其中有void* data，指向data。
    - 计划将Template中的 input/output 在子类构造函数中进行设定，对于增加Input/Ouput 感觉作用不大。
    - 全部连线完成后，点击按钮进行Pipeline/ RenderPass / Material 三者的生成.
    - 预计还需要一周，难度有些颇高。
---
### 2024年05月06日 22:54:24
  - 已经这么久没写代码了嘛。。。
  - 今天接触了BepInEX, 写了个通神榜的外挂，直接化身调库侠了。。。不过还是挺有意思的。
  - 需要把火影战记提上日程了。
  - 制作枪火重生Mod。
---
### 2024年5月9日01:50:06
  - BepInEx6 才支持IL2Cpp架构，花了三天时间重写ScriptEngine来实现热更新。
  - 明天开始恢复毕设的开发了，需要把Material Editor完成了。
---
### 2024年05月10日 00:08:30
  - 完成了数字魅影的Mod开发，直接化身天使。
  - 了解到了之前正交投影Z的范围问题，使用CSM 级联阴影。
---
### 2024年5月16日03:32:01
  - 化身Godot开发了，开新项目游戏。
  - 完成了读取文件进行属性配置。
    - 预制体通过ResourceMapper.json文件进行路径映射。
    - 属性通过PropertyMapper.json文件进行映射。
  - 已经是C#的形状了，确实是好用的一笔。
---
### 2024年5月21日01:12:59
  - 完成了枪械，子弹，玩家，场景的Debug模型。
  - 记录一下大致思路：
    - 枪械包含了子弹的ID，该ID的映射存储在IdMapper.json。其中的映射是ResourceMapper中的“name”属性，其指向.res
    - Debug 枪械模型包含Sprite2D 和一个Marker2D 来标记特效发射点。武器Node随Player攻击方向转动。
    - 之后的需要等毕设完成了，太久没有写毕设了，该完善一下其功能了。
  - 明天恢复渲染器的开发。待完成材质编辑器与CSM联机阴影。
---
### 2024年5月21日23:08:42
  - 新增了摄像的Debug平截头，几何着色器
  - 因为上述的完成，修复了长久以来的阴影问题，到达一定区间阴影直接断层式消失，搞半天原来是shader_depth的问题，我在frag里面将z<0的地方直接discard了。
---
### 2024年5月23日01:30:51
  - 今天没怎么写，添加了material editor的数据显示，大致就是在slottemplate中加入一个成员函数来显示需要显示的内容，然后在node区域中绘制。
---
### 2024年5月26日23:49:46
  - 现在M E能够显示shader的UBO数据了，并将其作为input，Material的shader切换无内存泄漏，且暂时安全无崩溃BUG。
  - 接下来需要将bindData这部分可视化，大致就是直接加一些新的计算节点，如dot，cross等。再加入原型节点，如model，camera等，这些数据将来自material挂载的模型示例。
### 2024年5月27日01:35:43
  - 有一个挺重要的修改，把Shader_Data_Binding_Func类型从void(*)(xxxx) 改成std::function<Shader_Data_Binding_Func_Type>
### 2024年5月27日02:30:50
  - 激动！！！！！！连连看终于成功了。有以下几个问题需要解决
    - shader编译缓存问题，计划直接套用之前Debug模式下的reload函数
    - 经典的shader重新加载，material重新handle后，drawFunc的lambda函数出问题了，毕竟旧slot被销毁了，现在好晚了，明天再解决吧。
    - 暂时只完成了Camera的数据连接，还有Light Model 等等，还有最后的材质应用到场景模型中等等。
    - 暂时只有UBO的数据连接。
### 2024年5月28日01:16:48
  - 现在能够将material应用到场景，并且实时响应，暂时还没支持Texture, 明天实现。已经暂时没有BUG了，修改了数据连接方式：
    - 在Material识别shader后，会新增一个Struct类型的节点，该节点由Material的input衍生而来，只有一个输出且与Material的input一一对应。
    - 在识别摄像，model这种通用类使用标识符，在Material的initDrawFunc中判断，其使用了input的CommonStruct中的对象，其保存了一个SlotBinding的成员结构。
    - 能够判断非通用类，其需要提供实际数据，通用类主需要提供字段即可，例如Camera.Projection ...
---
### 2024年05月28日 19:51:28
  - 支持Texture。
  - 毕设彻底完结。接下来开始重构代码，开始制作独立游戏。
---
### 2024年5月29日15:49:33
  - 面试了一个引擎开发岗，问题给我问懵逼了
    - 双线性插值
    - 矩阵可逆条件
    - 多线程与多进程，关键域，信号量
    - PBR
    - 虚函数表
### 2024年5月30日04:59:29
  - 加班到现在，Material Editor PBR 的基础支持了已经。能够可视化操作PBR材质。
  - Material Editor功能更加完善。修复了大量Shader Material 重新加载时的BUG。
### 2024年5月30日05:24:23
  - 现在材质编辑器小图也可以进行摄像操作了。
---
### 2024年5月31日00:05:20
  - 今天起来比较晚，又打了两把游戏，没写什么。增加了纹理PBR，还在测试。
  - 修复了若干细小BUG。
### 2024年5月31日00:55:08
  - 从纹理采样PBR属性，其中金属度似乎有点问题，不知道是代码问题还是什么。。。
---
### 2024年6月1日00:06:24 
  - PBR纹理采样正确了，对ME增加了纯数据的节点，具体实现没完成，只进行了框架搭建。
---
### 2024年6月2日17:48:09
  - 修了一个隐藏及其深的早期特大Bug, 当初SlotData在获取member时，没有考虑顺序问题，就在刚才才遇到了这个问题，导致整个程序渲染效果全部大错特错，不知道为什么现在才遇到。总之解决了。
### 2024年06月03日 01:18:54
  - 无IBL 的PBR 目前一切顺利，有一点小BUG与小不足。
    - Model切换材质后，Material Shader显示错误。
    - 纹理切换后，ME显示的任是初次设置的纹理。
    - 摄像Target概率归为nid
    - ME 摄像 moveSpeed过大
    - 滚轮响应精度不足。
### 2024年06月03日 21:24:19
  - SlotInput在着色器set binding数量变化是仍旧有BUG。
---
### 2024年6月5日17:29:49
  - 脱离苦海，明天答辩，今天发offer了
  - 完成了PBR的全部内容，但是vulkan有一个关于高粗糙度接缝问题，没有GL_TEXUTRE_CUBE_MAP_SAMPLENESS这个类似的选项。
---
### 2024年6月6日00:56:03
 - ​完成了Learn Opengl的PBR教程Vulkan版。由于机器不支持dynamic render，导致实现起来极其极其痛苦。在卷积环境贴图以及预滤波环境贴图时，不得不创建6个甚至更多的framebuffer来单独操作每层。不过好在最终结果是好的。
 - 其中还有一个问题，就是OpenGL有一个选项可以直接过度立方体边缘，但是Vulkan需要自己实现，最终我没实现该功能，在材质球上镜面反射在粗糙度较大时割裂感极强，但是在模型中看不出来，就懒得修复了。
 - 还有一个问题，就是Vulkan的坐标系是Y轴翻转的，导致按照教程得到的立方体贴图和BRDF积分图都是颠倒的。这个只需要把projection[1][1]翻转即可。
 - 这次是彻底的结束了，该项目也将长眠于此刻。
 - 今天找到工作了，未来将出发去长沙。
### 历时 140天15小时59分钟